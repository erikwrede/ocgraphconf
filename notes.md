The align_case_model code is currently incomplete. What I actually intended on doing is a branch and bound style algorithm. Let me describe the problem:

A model is an object-centric petri (oc_petri_net) net, a case is a graph (case.rs). Two case graphs can be aligned. This uses an algorithm, calculating the cost to create an injective function from one graph to the other. Basically, the alignment states the similarity of each case (align_case.rs). Now, lets talk models. A model is a oc petri net. A petri net has a marking (marking.rs). A marking has certain enabled transitions you can fire with tokens from the connecting places. the function get_firing_combinations does that for you. Keep in mind OC petri nets have token ids, and places are labeled. You can fire enabled transitions as in any other petri net. You can generate a partial case graph from any firing sequence of the petri net. For every firing, add a new event node of the correct event type, and connect the event node in the directly follows relation as well as connecting it to the correct object nodes. The object nodes involved in an event can be identified via the token id of the tokens used in the firing. A petri net marking is in a final state if all tokens are in the final marking. In that case we have a complete case graph and can do an alignment to get the definitive cost of a case the model allowed, aligned to our query case.
The branch and bound algorithm works as follows: we have a global upper and lower cost bound. keep in mind our tree may be infinite. We start with an empty marking and thus an empty partial case in the initial node. Now we can branch off from the node. we either add one new token to an initial place, or we fire one of the possible get_firing combinations for this marking. Thus, each node represents a marking along with the partial case graph of the firing combinations that got it here. Now we can calculate the current minimum cost for each node (leave that for later) and greedily select the next node that fits best. For this, for each node and the current partial alignment keep a list of nodes in our query graph mapped to void nodes and greedily select a possible firing that can add more of these missing currently filled by void nodes to the partial graph so our cost decreases. Again keep in mind all is infinite. We can Formulate a global upper bound as soon as we find any one completed marking with our model in any node. in this case, the global upper bound is updated to the cost of the alignment between that case and our query case, and all branches with higher minimum cost are pruned. the minimum cost per node is also something to calculate later.